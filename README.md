# Simple File Transfer v1.0

This document specifies version 1.0 of the Simple File Transfer (SiFT) protocol, which allows a client to send file commands to a server for execution. SiFT v1.0 secures the communication with cryptographic protections, ensuring message confidentiality, integrity, and authenticity. The server and client communicate via a TCP/IP network connection.

## Features

- **Secure Communication**: Uses AES-GCM for encryption, integrity, and authentication, with sequence numbers to protect against replay attacks.
- **Login Protocol**: Establishes a shared secret key using RSA for authentication, and AES for encrypted communication.
- **File Commands**: Supports commands like `pwd`, `lst`, `chd`, `mkd`, `del`, `upl`, and `dnl` to manage files and directories.
- **File Transfer Protocols**: Supports the Upload and Download protocols for transferring files in secure, fragmented messages.
- **Custom IP Address and Port**: You can configure the IP address and server port to connect to a specific target device.

## Installation

1. **Unzip the File**: Extract the contents of the zip file to a directory.
2. **Configure IP Address and Port**:
   - Open the `server.py` file and locate the section where the server binds to an IP address and port. By default, the server listens on port `5150`.
   - Change the IP address and port as desired:
     ```python
     host = '0.0.0.0'  # Set the target IP address or '0.0.0.0' to listen on all interfaces
     port = 5150  # Change the port number if needed
     ```
   - In the `client.py` file, configure the target IP address and port to match the server settings:
     ```python
     host = 'target_device_ip'  # Replace with the IP address of the server
     port = 5150  # Set the same port as the server
     ```
3. **Start the Server**: 
   - Open a terminal window.
   - Navigate to the `server` folder.
   - Start the server with: 
     ```bash
     python3 server.py
     ```
   - The server will listen for incoming client connections on the configured IP and port.

4. **Start the Client**:
   - Open another terminal window.
   - Navigate to the `client` folder.
   - Start the client with:
     ```bash
     python3 client.py
     ```
   - The client will connect to the server using the specified IP address and port.

## Running the Application

Once both the server and client are running, you can log in using one of the following test credentials:

- `alice` / `aaa`
- `bob` / `bbb`
- `charlie` / `ccc`

Once logged in, type `help` in the client to view the available commands. 

- `pwd` to print the current directory.
- `lst` to list contents of the current directory.
- `chd <dir>` to change directory.
- `mkd <dir>` to create a new directory.
- `del <file/dir>` to delete a file or directory.
- `upl <file>` to upload a file to the server.
- `dnl <file>` to download a file from the server.

## Protocols in Detail

### 1. **Message Transfer Protocol (MTP)**

MTP secures all communication between the client and server using AES-GCM encryption with a shared transfer key derived during the login process. The message format includes a version, type, length, sequence number, random number, reserved field, encrypted payload, and a MAC for authentication.

### 2. **Login Protocol**

The login process involves the client sending a `login_req` message containing:
- A timestamp of the request.
- The username and password.
- A fresh random number (`client_random`).

The server responds with a `login_res` message containing:
- A hash of the request.
- A fresh random number generated by the server (`server_random`).

The shared transfer key for all further communications is derived from `client_random` and `server_random` using HKDF.

### 3. **Commands Protocol**

Once logged in, the client can send commands to the server, such as changing directories (`chd`), listing files (`lst`), or uploading files (`upl`). Commands are protected using the final transfer key, and the server responds with the result of each command. The server ensures that commands are valid and that users cannot access files outside their root directory.

### 4. **Upload Protocol**

When uploading files, the file is divided into fragments, which are sent in multiple `upload_req` messages. The server responds with `upload_res` to confirm receipt. File uploads are encrypted using the session key established during login.

### 5. **Download Protocol**

File download follows a similar process. The client requests a file with `dnload_req`, and the server responds with `dnload_res` containing file fragments. The client verifies the file's integrity by checking the SHA-256 hash of the received data.

## Security Considerations

- **Encryption**: All communication between the client and server is encrypted using AES-GCM with the session key.
- **Authentication**: The client is authenticated with a username and password, while the server is authenticated using RSA public/private key pairs.
- **Replay Protection**: The MTP protocol includes sequence numbers to protect against replay attacks.
- **Password Storage**: Passwords are stored securely on the server as hashes, using a secure password hashing algorithm like PBKDF2, scrypt, or Argon2.

## Example Use Case

1. **Login**: 
   - Client sends a `login_req` with the username `alice` and password `aaa`.
   - Server verifies credentials and responds with `login_res`.
2. **Command Execution**:
   - Client runs `pwd` to print the current directory.
   - Server responds with the current directory path.
3. **File Upload**:
   - Client uploads a file using `upl` command.
   - File is divided into fragments and sent using `upload_req`.
4. **File Download**:
   - Client requests a file using `dnl`.
   - Server sends the file in fragments via `dnload_res`.

## Conclusion

SiFT v1.0 ensures secure, reliable communication between a client and server for file transfers and command execution. It uses modern cryptographic techniques to protect against eavesdropping, modification, and replay attacks, making it suitable for use over untrusted networks. Additionally, the flexibility to set custom IP addresses and ports allows SiFT to be easily connected to a target device on a network.
